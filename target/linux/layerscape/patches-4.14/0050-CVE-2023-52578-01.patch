--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -4561,4 +4561,9 @@ void dev_fp_stats_get_register(fp_iface_
 void dev_fp_stats_get_deregister(void);
 #endif
 
+/* Note: Avoid these macros in fast path, prefer per-cpu or per-queue counters. */
+#define DEV_STATS_INC(DEV, FIELD) atomic_long_inc(&(DEV)->stats.__##FIELD)
+#define DEV_STATS_ADD(DEV, FIELD, VAL) 	\
+		atomic_long_add((VAL), &(DEV)->stats.__##FIELD)
+
 #endif	/* _LINUX_NETDEVICE_H */
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -125,7 +125,7 @@ static int deliver_clone(const struct ne
 
 	skb = skb_clone(skb, GFP_ATOMIC);
 	if (!skb) {
-		dev->stats.tx_dropped++;
+		DEV_STATS_INC(dev, tx_dropped);
 		return -ENOMEM;
 	}
 
@@ -250,7 +250,7 @@ static void maybe_deliver_addr(struct ne
 
 	skb = skb_copy(skb, GFP_ATOMIC);
 	if (!skb) {
-		dev->stats.tx_dropped++;
+		DEV_STATS_INC(dev, tx_dropped);
 		return;
 	}
 
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -202,12 +202,12 @@ int br_handle_frame_finish(struct net *n
 			if ((mdst && mdst->mglist) ||
 			    br_multicast_is_router(br)) {
 				local_rcv = true;
-				br->dev->stats.multicast++;
+				DEV_STATS_INC(br->dev, multicast);
 			}
 			mcast_hit = true;
 		} else {
 			local_rcv = true;
-			br->dev->stats.multicast++;
+			DEV_STATS_INC(br->dev, multicast);
 		}
 		break;
 	case BR_PKT_UNICAST:
