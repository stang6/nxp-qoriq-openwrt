--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -1067,6 +1067,22 @@ bool blk_mq_dispatch_rq_list(struct requ
 				break;
 
 			/*
+			 * Add one explicit barrier since blk_mq_get_driver_tag() may
+			 * not imply barrier in case of failure.
+			 *
+			 * Order adding us to wait queue and allocating driver tag.
+			 *
+			 * The pair is the one implied in sbitmap_queue_wake_up() which
+			 * orders clearing sbitmap tag bits and waitqueue_active() in
+			 * __sbitmap_queue_wake_up(), since waitqueue_active() is lockless
+			 *
+			 * Otherwise, re-order of adding wait queue and getting driver tag
+			 * may cause __sbitmap_queue_wake_up() to wake up nothing because
+			 * the waitqueue_active() may not observe us in wait queue.
+			 */
+			smp_mb();
+
+			/*
 			 * It's possible that a tag was freed in the window
 			 * between the allocation failure and adding the
 			 * hardware queue to the wait queue.
