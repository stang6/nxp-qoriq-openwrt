--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -92,6 +92,7 @@ struct Qdisc {
 	struct gnet_stats_basic_packed bstats;
 	seqcount_t		running;
 	struct gnet_stats_queue	qstats;
+	int                     owner;
 	unsigned long		state;
 	struct Qdisc            *next_sched;
 	struct sk_buff		*skb_bad_txq;
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3212,6 +3212,11 @@ static inline int __dev_xmit_skb(struct
 	int rc;
 
 	qdisc_calculate_pkt_len(skb, q);
+
+	if (unlikely(READ_ONCE(q->owner) == smp_processor_id())) {
+		kfree_skb(skb);
+		return NET_XMIT_DROP;
+	}
 	/*
 	 * Heuristic to force contended enqueues to serialize on a
 	 * separate lock before trying to get qdisc main lock.
@@ -3247,7 +3252,9 @@ static inline int __dev_xmit_skb(struct
 
 		rc = NET_XMIT_SUCCESS;
 	} else {
+		WRITE_ONCE(q->owner, smp_processor_id());
 		rc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;
+		WRITE_ONCE(q->owner, -1);
 		if (qdisc_run_begin(q)) {
 			if (unlikely(contended)) {
 				spin_unlock(&q->busylock);
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -504,6 +504,7 @@ struct Qdisc *qdisc_alloc(struct netdev_
 	sch->enqueue = ops->enqueue;
 	sch->dequeue = ops->dequeue;
 	sch->dev_queue = dev_queue;
+	sch->owner = -1;
 	dev_hold(dev);
 	refcount_set(&sch->refcnt, 1);
 
